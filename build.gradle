// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    ext {
        kotlin_version = '1.3.72'
    }
    //配置工程 仓库地址
    repositories {
        mavenCentral()
        jcenter()
        maven { url 'https://jitpack.io' }
        google()
        //配置本地私有maven
        maven {
            name 'hfyPersionalRepo'
            url 'http://localhost:8081:/nexus/repositories'
            //访问校验
            credentials{
                username = 'admin'
                password = 'admin123'
            }
        }

    }
    // buildscript 的 dependencies 用于配置工程 "插件"依赖。不同与project 的dependencies。
    dependencies {
        classpath 'com.android.tools.build:gradle:4.0.2' //可用于配置Android module是 'application' 或 'library'
        classpath 'com.google.gms:google-services:4.2.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
plugins {
    id "org.sonarqube" version "2.6"
}
allprojects {
    repositories {
        mavenCentral()
        jcenter()
        maven { url 'https://jitpack.io' }
        google()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}


/**
 * gradle 学习： Project
 * 1. 一个Android工程 和 每个Android module，就是一个gradle project （他们都有一个build.gradle文件）
 * 2. 在build.gradle中写的逻辑，实际就是调用Project这个类的方法。一个build.gradle文件编译后就是一个Project对象
 * 3. 在build.gradle中写的代码就是配置代码，在配置阶段就执行了！而添加的task的内容逻辑 是在执行阶段执行的。
 */

//Gradle提供了对project状态配置监听的接口回调,以方便我们来配置一些Project的配置属性,监听主要分为两大类,
// 一种是通过project（project.beginEvaluate配置前调用,project.afterEvaluate配置后调用）进行 回调，
// 一种是通过gradle(this.gradle.beforeProject配置前调用,this.gradle.afterProject配置后调用)进行回调,
// 作用域也有不同 ,project是只针对当前project实现进行的监听,gradle监听是针对于所有的project而言的。
// beforeEvaluate方法说的很清楚是配置之前调用,但你要是直接当前build.gradle中使用是肯定不会调用到的,
// 因为Project都没配置好还有他什么事情(也是无奈),afterEvaluate是配置之后调用只要project配置成功均会调用.

//这个不会执行
beforeEvaluate {
    println "root beforeEvaluate!!!"
}

//当前工程的配置结束时执行--最常用
afterEvaluate {
    println "root afterEvaluate!!!"
}

//每个子project 配置前 都会执行
gradle.beforeProject {
    println "gradle.beforeProject!!!"
}

//每个子project 配置后 都会执行
gradle.afterProject {
    println "gradle.afterProject!!!"
}

//全部执行完毕后
gradle.buildFinished {
    println "root buildFinished!!!"
}

//输出所有project
def printAllProjects(){
    getAllprojects().eachWithIndex { Project project, int index ->
        if (index == 0){
            println "----${index}, root project ----"
        }else{
            println "----${index}, project:${project.name} ----"

        }
    }

    println "getChildProjects().size:${getChildProjects().size()}"
    println "getSubprojects().size:${getSubprojects().size()}"
//    getParent()
    println "root project name:${getRootProject().name}"
}

printAllProjects()


//找到指定project，并配置（但一般不会这么干）
//project('app'){Project project->
//    project.beforeEvaluate {
//        println "app beforeEvaluate!!!"
//    }
//
//    apply plugin ''
//
//    android{}
//    dependencies {
//    }
//}

//针对所有project（root project和 所有子project）
//allprojects {
//    group 'com.hfy'
//    version '1.0.0'
//}

//所有子project
//subprojects {Project project->
//    //如果是library，则添加 上传maven插件
//    if (project.plugins.hasPlugin('com.android.library')){
////        apply from: '../publishToMaven.gradle'
//    }
//}

//println project('app').group

//扩展属性：使用 ext{} 给当前project扩展属性。
// 子project 是继承root project的，所以 子project 也可以使用这个扩展属性
//ext {
//    mCompileSdkVersion = 30
//}

//在root project中引用common.gradle ，则common.gradle定义的扩展属性，所有project都可使用
apply from: rootProject.file('common.gradle')


/**
 * gradle 提供的文件相关API 只能用于本root工程下的文件操作！！！
 * 获取 文件路径
 */
println "RootDir: ${getRootDir().absolutePath}"
println "BuildDir:${getBuildDir().absolutePath}"
println "ProjectDir:${getProjectDir().absolutePath}"

/**
 * 文件定位：file(fileName)
 * 在当前project目录中找名为fileName的文件,相对于new file(path), 只需要传文件名即可，不需要路径
 */
println getFileContent('common.gradle')
def getFileContent(String fileName){
    try {
        def file = file(fileName)
        return file.text
    }catch(GradleException e){
        println e.message
    }
    return null
}

/**
 * 文件、文件夹 的拷贝，so easy！
 */
copy {
    from file('README.md')
    into getBuildDir()
    exclude{} //排除
    rename{
        'README2.md' //重命名
    }
}

/**
 * 文件树的遍历: fileTree.visit
 */
//fileTree('gradle/'){ ConfigurableFileTree fileTree->
//    fileTree.visit {FileVisitDetails visitDetails ->
//        println 'visitDetails ：'+visitDetails.name
//        visitDetails.copyTo(file(getRootDir().absolutePath+"/test/"+visitDetails.name))
//    }
//}

fileTree('gradle/'){ConfigurableFileTree configurableFileTree ->
    configurableFileTree.visit {FileVisitDetails fileVisitDetails ->
        copy {
            from fileVisitDetails.file
            into rootProject.getBuildDir().absolutePath+'/test/'
        }
    }
}